// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/native_hash.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NativeHashBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeHashBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeHashBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// FUNCTION DECLARATIONS
  void sha256_init(
    ffi.Pointer<SHA256_CTX> ctx,
  ) {
    return _sha256_init(
      ctx,
    );
  }

  late final _sha256_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SHA256_CTX>)>>(
          'sha256_init');
  late final _sha256_init =
      _sha256_initPtr.asFunction<void Function(ffi.Pointer<SHA256_CTX>)>();

  void sha256_update(
    ffi.Pointer<SHA256_CTX> ctx,
    ffi.Pointer<BYTE> data,
    int len,
  ) {
    return _sha256_update(
      ctx,
      data,
      len,
    );
  }

  late final _sha256_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SHA256_CTX>, ffi.Pointer<BYTE>,
              ffi.Size)>>('sha256_update');
  late final _sha256_update = _sha256_updatePtr.asFunction<
      void Function(ffi.Pointer<SHA256_CTX>, ffi.Pointer<BYTE>, int)>();

  void sha256_final(
    ffi.Pointer<SHA256_CTX> ctx,
    ffi.Pointer<BYTE> hash,
  ) {
    return _sha256_final(
      ctx,
      hash,
    );
  }

  late final _sha256_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SHA256_CTX>, ffi.Pointer<BYTE>)>>('sha256_final');
  late final _sha256_final = _sha256_finalPtr
      .asFunction<void Function(ffi.Pointer<SHA256_CTX>, ffi.Pointer<BYTE>)>();

  /// FUNCTION DECLARATIONS
  void md2_init(
    ffi.Pointer<MD2_CTX> ctx,
  ) {
    return _md2_init(
      ctx,
    );
  }

  late final _md2_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MD2_CTX>)>>(
          'md2_init');
  late final _md2_init =
      _md2_initPtr.asFunction<void Function(ffi.Pointer<MD2_CTX>)>();

  void md2_update(
    ffi.Pointer<MD2_CTX> ctx,
    ffi.Pointer<BYTE1> data,
    int len,
  ) {
    return _md2_update(
      ctx,
      data,
      len,
    );
  }

  late final _md2_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<MD2_CTX>, ffi.Pointer<BYTE1>,
              ffi.Size)>>('md2_update');
  late final _md2_update = _md2_updatePtr.asFunction<
      void Function(ffi.Pointer<MD2_CTX>, ffi.Pointer<BYTE1>, int)>();

  void md2_final(
    ffi.Pointer<MD2_CTX> ctx,
    ffi.Pointer<BYTE1> hash,
  ) {
    return _md2_final(
      ctx,
      hash,
    );
  }

  late final _md2_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<MD2_CTX>, ffi.Pointer<BYTE1>)>>('md2_final');
  late final _md2_final = _md2_finalPtr
      .asFunction<void Function(ffi.Pointer<MD2_CTX>, ffi.Pointer<BYTE1>)>();

  /// FUNCTION DECLARATIONS
  void md5_init(
    ffi.Pointer<MD5_CTX> ctx,
  ) {
    return _md5_init(
      ctx,
    );
  }

  late final _md5_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MD5_CTX>)>>(
          'md5_init');
  late final _md5_init =
      _md5_initPtr.asFunction<void Function(ffi.Pointer<MD5_CTX>)>();

  void md5_update(
    ffi.Pointer<MD5_CTX> ctx,
    ffi.Pointer<BYTE2> data,
    int len,
  ) {
    return _md5_update(
      ctx,
      data,
      len,
    );
  }

  late final _md5_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<MD5_CTX>, ffi.Pointer<BYTE2>,
              ffi.Size)>>('md5_update');
  late final _md5_update = _md5_updatePtr.asFunction<
      void Function(ffi.Pointer<MD5_CTX>, ffi.Pointer<BYTE2>, int)>();

  void md5_final(
    ffi.Pointer<MD5_CTX> ctx,
    ffi.Pointer<BYTE2> hash,
  ) {
    return _md5_final(
      ctx,
      hash,
    );
  }

  late final _md5_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<MD5_CTX>, ffi.Pointer<BYTE2>)>>('md5_final');
  late final _md5_final = _md5_finalPtr
      .asFunction<void Function(ffi.Pointer<MD5_CTX>, ffi.Pointer<BYTE2>)>();

  /// FUNCTION DECLARATIONS **********************/
  /// // Performs IN PLACE rotation of the input. Assumes input is NULL terminated.
  /// // Preserves each charcter's case. Ignores non alphabetic characters.
  void rot13(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _rot13(
      str,
    );
  }

  late final _rot13Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'rot13');
  late final _rot13 =
      _rot13Ptr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// FUNCTION DECLARATIONS
  void sha1_init(
    ffi.Pointer<SHA1_CTX> ctx,
  ) {
    return _sha1_init(
      ctx,
    );
  }

  late final _sha1_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SHA1_CTX>)>>(
          'sha1_init');
  late final _sha1_init =
      _sha1_initPtr.asFunction<void Function(ffi.Pointer<SHA1_CTX>)>();

  void sha1_update(
    ffi.Pointer<SHA1_CTX> ctx,
    ffi.Pointer<BYTE3> data,
    int len,
  ) {
    return _sha1_update(
      ctx,
      data,
      len,
    );
  }

  late final _sha1_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SHA1_CTX>, ffi.Pointer<BYTE3>,
              ffi.Size)>>('sha1_update');
  late final _sha1_update = _sha1_updatePtr.asFunction<
      void Function(ffi.Pointer<SHA1_CTX>, ffi.Pointer<BYTE3>, int)>();

  void sha1_final(
    ffi.Pointer<SHA1_CTX> ctx,
    ffi.Pointer<BYTE3> hash,
  ) {
    return _sha1_final(
      ctx,
      hash,
    );
  }

  late final _sha1_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SHA1_CTX>, ffi.Pointer<BYTE3>)>>('sha1_final');
  late final _sha1_final = _sha1_finalPtr
      .asFunction<void Function(ffi.Pointer<SHA1_CTX>, ffi.Pointer<BYTE3>)>();
}

final class SHA256_CTX extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<BYTE> data;

  @WORD()
  external int datalen;

  @ffi.UnsignedLongLong()
  external int bitlen;

  @ffi.Array.multi([8])
  external ffi.Array<WORD> state;
}

/// DATA TYPES
typedef BYTE = ffi.UnsignedChar;
typedef DartBYTE = int;
typedef WORD = ffi.UnsignedInt;
typedef DartWORD = int;

final class MD2_CTX extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<BYTE1> data;

  @ffi.Array.multi([48])
  external ffi.Array<BYTE1> state;

  @ffi.Array.multi([16])
  external ffi.Array<BYTE1> checksum;

  @ffi.Int()
  external int len;
}

/// DATA TYPES
typedef BYTE1 = ffi.UnsignedChar;
typedef DartBYTE1 = int;

final class MD5_CTX extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<BYTE2> data;

  @WORD1()
  external int datalen;

  @ffi.UnsignedLongLong()
  external int bitlen;

  @ffi.Array.multi([4])
  external ffi.Array<WORD1> state;
}

/// DATA TYPES
typedef BYTE2 = ffi.UnsignedChar;
typedef DartBYTE2 = int;
typedef WORD1 = ffi.UnsignedInt;
typedef DartWORD1 = int;

final class SHA1_CTX extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<BYTE3> data;

  @WORD2()
  external int datalen;

  @ffi.UnsignedLongLong()
  external int bitlen;

  @ffi.Array.multi([5])
  external ffi.Array<WORD2> state;

  @ffi.Array.multi([4])
  external ffi.Array<WORD2> k;
}

/// DATA TYPES
typedef BYTE3 = ffi.UnsignedChar;
typedef DartBYTE3 = int;
typedef WORD2 = ffi.UnsignedInt;
typedef DartWORD2 = int;

const int SHA256_BLOCK_SIZE = 32;

const int MD2_BLOCK_SIZE = 16;

const int MD5_BLOCK_SIZE = 16;

const int SHA1_BLOCK_SIZE = 20;
